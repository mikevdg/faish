Application/vnd.squl1 ModuleExport size=38590
mParser276:2148A3C17554C8F7E9473C154B067948
mBase65:A4791430600148AF45B326E13D8512EE
--
module:[	mCompilermanuallyparsed1] metadata:( description:["

I'm a disposable compiler; I have been parsed manually to expand operators.

] ).

:[" About statements and signatures.

This compiler has the concept of hard statements and soft statements. A hard statement is one that already resides in a module and can be queried. A soft statement is one that is made of lists and data structures that represent the hard statement - soft statements are easier to manipulate and are what we use in compilation steps. The last step is to bake the soft statements into hard statements and add them to a module.

A soft statement is a list made of (h:emnut:) and (empty). As a list, each element can be one of:

* (atom:["name])
* (variable:["Name])
* (statement:List)
* (literal: ...TODO...)

TODO: line and column numbers in the source code.
TODO: typing information.

A soft signature is a flat list containing only:

* (atom:["name])
* (type:Type)

].

:[" Compilation steps.

Currently, just one module is passed around to manage the compilation. Everything is stored in there:
- soft signatures (declarations)
- hard signatures
- soft statements
- hard statements
- errors.
- (TODO: eventually, compiled code)

The module's exports will determine what queries are possible. The final step of compilation would be to generate code based on those exports, and strip the module of anything that those queries cannot reach.

TODO: Use a special prefix for all statements involved in the compilation process, so they can be removed when finished. $:~.

The steps are as follows:

- Parse the textual source code into soft statements. Everything works on soft statements.
- Harden all the declarations into signatures.
- Expand literals.
- Harden statements:
	* Check that the type matches.
      * Check for errors
	( TODO check for:
		* Statements that are not used.
		* Premises that have no matches.
		* Exports that are not used???
		* Named variables that are only used once.
		* Warn about named variables that are used more than twice.
		* Mismatched variable types.
		* Missing base cases?  )

TODO: incremental compilation.
TODO: funky parsing, such as cuddliness and parenthesis elision.

- Finally and only if code is to be generated, compile the exports as queries into executable code and strip the module.

For migrating between images, also make a tool that converts a module into Smalltalk (or other language) statements that create a module from scratch.

].

then:( parse:S module:Mr )
if:( create:module result:M1 )
if:( string:S readSoftStatementsInto:( +:M1 -:Mr ) ).

:["Parse the given statement in the context of the given module, but do not add it to that module.].

then:( parse:Statement inModule:M -:H)
if:( string:Statement statementStringAtHead:SHead rest:S2 )
if:( parseStatement:SHead module:( +:M -:_ ) result:( success:H ) ).

:[" TODO: process those module IDs. ].

then:( parseHeader:(+:F1 -:F4) module:(+:M -:M) )
if:( string:( +:F1 -:F2 ) expect:["Application/vnd.squl1 ModuleExport size=] )
if:( string:( +:F2 -:F3 ) consumeNumber:Size )
if:( string:( +:F3 -:F4 ) readModuleIds:ModuleIds ).

:["TODO: Error handling. All soft statements and signatures need to include a line number and column number.

Ordinary compilation errors can go into the module we're building.

 ].

then:( hardenDeclarationsIn:( +:M1 -:M2 ) )
if:( 
	module:M1 
	query:( $:( softStatement:( h:(atom:["declare]) emnut:_ ) ) )
	iterator:It )
if:( iterator:It hardenSignaturesIn:( +:M1 -:M2 ) ).

then:( iterator:It hardenSignaturesIn:( +:M1 -:M5 ) )
if:( iterator:It value:($:(softStatement:Ss)) nextIterator:It2 )
if:( equals:Ss with:( declare:_ ) )
if:( create:variableMapping result:V )
if:( softStatement:Ss module:(+:M1 -:M3) variableMapping:(+:V -:_) hardened:Sh )
if:( module:M2 add:Sh result:M3 )
if:( module:M3 add:( $:(signature:Sh) softSignature:Ss ) result:M4 )
if:( iterator:It2 hardenSignaturesIn:( +:M4 -:M5 ) ).

then:( iterator:It hardenStatementsIn:( +:M1 -:M4 ) )
if:( iterator:It value:($:(softStatement:Ss)) nextIterator:It2 )
if:( create:variableMapping result:V )
if:( softStatement:Ss module:(+:M1 -:M3) variableMapping:(+:V -:_) hardened:Sh )
if:( module:M2 add:Sh result:M3 )
if:( iterator:It2 hardenStatementsIn:( +:M3 -:M4 ) ).

then:( string:Empty readSoftStatementsInto:( +:M -:M ) )
if:( stripWhitespace:Empty result:["] ).

then:( string:S1 readSoftStatementsInto:( +:M1 -:M4 ) )
if:( string:S1 statementStringAtHead:SHead rest:S2 )
if:( parseStatement:SHead module:( +:M1 -:M2 ) result:( success:H ) )
if:( notEqual:H with:( h:(atom:["declare]) emnut:_ ) )
if:( module:M2 add:H result:M3 )
if:( string:S2 readSoftStatementsInto:( +:M3 -:M4 ) ).

then:( string:S1 statementStringAtHead:Tr rest:R )
if:( terminator:T )
if:( h:T emnut:["] array:Tr )
if:( h:T emnut:R array:S1 ).

then:( string:Hemnut statementStringAtHead:Hem rest:Nut )
if:( h:B emnut:Okluz array:Hemnut )
if:( noResults:( blockStartCharacter:B ) )
if:( noResults:( terminator:B ) )
if:( string:Okluz statementStringAtHead:Ok rest:Nut )
if:( h:B emnut:Ok array:Hem ).

then:( string:Hemnut statementStringAtHead:Hem rest:Nut )
if:( readBlock:Hemnut block:Bok rest:Luz )
if:( string:Luz statementStringAtHead:Dag rest:Nut )
if:( hem:Bok nut:Dag array:Hem ).

then:( readBlock:Hemnut block:BlockWithBrackets rest:Luz )
if:( blockStartCharacter:StartBlock )
if:( h:StartBlock emnut:Emnut array:Hemnut )
if:( readToEndOfBlock:Emnut block:BlockWithoutBrackets rest:Luz )
if:( addBlockBrackets:BlockWithoutBrackets -:BlockWithBrackets ).

test:( readBlock:["[b]x] block:["[b]] rest:["x] ).

then:( readToEndOfBlock:InsideBlock block:BlockWithoutBrackets rest:Luz )
if:( h:H emnut:Emnut array:InsideBlock )
if:( blockStartCharacter:Bs )
if:( notEqual:H with:Bs )
if:( blockEndCharacter:Be )
if:( notEqual:H with:Be )
if:( readToEndOfBlock:Emnut block:RestOfBlock rest:Luz )
if:( h:H emnut:RestOfBlock array:BlockWithoutBrackets ).

then:( readToEndOfBlock:InsideBlock block:BlockWithoutBrackets rest:Luz )
if:( blockStartCharacter:Bs )
if:( h:Bs emnut:Emnut array:InsideBlock )
if:( readBlock:InsideBlock block:InnerBlock rest:Rest )
if:( addBlockBrackets:InnerBlock -:InnerBlockWithBrackets )
if:( readToEndOfBlock:Rest block:RestOfBlock rest:Luz )
if:( hem:InnerBlockWithBrackets nut:RestOfBlock array:BlockWithoutBrackets ).

then:( readToEndOfBlock:InsideBlock block:["] rest:Emnut )
if:( blockEndCharacter:Be )
if:( h:Be emnut:Emnut array:InsideBlock ).

then:( test:( readToEndOfBlock:Emnut block:["abc] rest:["b] ) )
if:( h:H emnut:Emnut array:["[abc]b] ).

then:( test:( readToEndOfBlock:Emnut block:["ab[d]c] rest:["b] ) )
if:( h:H emnut:Emnut array:["[ab[d]c]b] ).

then:( addBlockBrackets:BlockWithoutBrackets -:BlockWithBrackets )
if:( blockStartCharacter:Bs )
if:( blockEndCharacter:Be )
if:( h:Bs emnut:BlockWithoutBrackets array:B1 )
if:( hemnu:B1 t:Be array:BlockWithBrackets ).

test:( addBlockBrackets:["a] -:["[a]] ).

blockStartCharacter:[+91].

blockEndCharacter:[+93].

test:( string:[".] statementStringAtHead:[".] rest:["] ).

test:(string:["a.] statementStringAtHead:["a.] rest:["]).

test:(string:["a. b.] statementStringAtHead:["a.] rest:[" b.]).

test:(string:["a? b.] statementStringAtHead:["a?] rest:[" b.]).

test:(string:["[a.] b. c. ] statementStringAtHead:["[a.] b.] rest:[" c. ]).

test:(string:["a (b c). ] statementStringAtHead:["a (b c).] rest:[" ]).

:["TODO: string:statementStringAtHead:rest: can fail at the end of the file. It needs an error. ].

string:( +:_ -:["] ) expect:["].

then:( string:( +:F1 -:F2 ) expect:S )
if:( h:H emnut:Emnut array:F1 )
if:( h:H emnut:Okluz array:S )
if:( string:( +:Emnut -:F2 ) expect:Okluz ).

string:( +:["] -:_ ) consumeNumber:[+0].

then:( string:( +:F1 -:F2 ) consumeNumber:N )
if:( string:F1 digitStr:Digits rest:F2 )
if:( parse:Digits integer:N ).

then:( string:Str digitStr:["] rest:Str )
if:( h:H emnut:Emnut array:Str )
if:( noResults:( parseChar:H integer:_ ) ).

then:( string:F digitStr:Digits rest:Rest )
if:( h:H emnut:Emnut array:F )
if:( parseChar:H integer:_ )
if:( h:H emnut:Okluz array:Digits )
if:( string:Emnut digitStr:Okluz rest:Rest ).

:["TODO: read the module IDs properly. ].

then:( string:( +:F -:Mnut ) readModuleIds:todo )
if:( h:['-] emnut:Emnut array:F1 )
if:( h:['-] emnut:Mnut array:Emnut )
if:( h:['
] emnut:Nut array:Mnut ).

then:( string:( +:F1 -:F2 ) readModuleIds:todo )
if:( h:H emnut:Emnut array:F1 )
if:( notEqual:H with:['-] )
if:( string:(+:Emnut -:F2 ) readModuleIds:todo ).

:[" Soft statements are statements that have been broken up into their components so that they can be worked with using Squl code.

Atoms become ( atom:String )
Variables become ( variable:String ).
Most other literals remain unchanged.

Statements are converted to lists. 

E.g.
a b.
becomes:
(h:(atom:["a]) emnut:(h:(atom:["b]) emnut:empty).

a (b c) d X.
becomes 
(
h:(atom:["a]) 
emnut:( 
	h:( 
		h:(atom:["b]) 
		emnut:(h:(atom:["c]) emnut:empty) 
	emnut:( 
		h:(atom:["d]) 
		emnut:(h:(variable:["X]) emnut:empty)
	)
)
).

In the new version of the language:

a b.
becomes:
( (atom ["a]) |= ( (atom ["b]) |= empty ) ).

(a (b c) d X)
becomes:
( 
	(atom ["a]) 
	|= 
	(
		(
			(atom ["b]) 
			|= 
			(
				(atom ["c]) |= empty
			)
		)
		|= 
		(
			(atom ["d]) 
			|= 
			(
				(variable ["X])
				|=
				empty
			)
		)
	)
)

].

:[" Parse one statement including terminator and trailing whitespace. ].

then:( 
	parseStatement:String
	module:(+:M -:M6 )
	result:( success:H) )
if:(
	parse:outerStatement
	source:String
	remaining:["]
	parsed:( success:SoftStatement )
	module:( +:M -:M2 ) )
if:( 	
	cookLiterals:(+:SoftStatement -:SS2 )
	module:( +:M2 -:M3 ) )
if:( 
	create:variableMapping result:V1 )
if:( 	
	softStatement:SS2 
	module:( +:M3 -:M4 ) 
	variableMapping:(+:V1 -:V2)
	hardened:H )
if:( 	
	module:M4 add:H result:M5 )
if:( 	
	module:M5 add:(metadata:(statement:H source:String)) result:M6 ).

then:( 
	parse:outerStatement
	source:Hemnut
	remaining: Nut
	parsed:( success:Result )
	module:( +:M1 -:M2 ) )
if:(	
	terminator:Terminator )
if:(	
	array:Hemnut split:Terminator hem:Source nut:AfterTerminator )
if:(
	stripWhitespace:AfterTerminator result:Nut)
if:(
	parse:statement
	source:Source
	remaining:BeforeTerminator
	parsed:( success:Result )
	module:( +:M1 -:M2 ) )
if:(
	stripWhitespace:BeforeTerminator result:["] ).

then:( test:(outerStatement:S) )
if:( create:module result:M )
if:( 
	parse:outerStatement
	source:["a b.]
	remaining:["]
	parsed:S
	module:( +:M -:X ) ).

:[" The next statement is "if we hit a ')', then maybe we've finished a statement. ].

then:( parse:statement source:S remaining:S parsed:( success:empty )  module:( +:M -:M ))
if:( h:[')] emnut:Emnut array:S).

then:( 
	parse:statement 
	source:Hemnut
	remaining:Nut
	parsed:( success:Result ) 
	module:( +:M1 -:M3 ) )
if:( 
	parse:clause
	source:Hemnut
	remaining:Luz
      parsed:( success:Clause )
      module:( +:M1 -:M2 ) )
if:( 
	parse:statement
	source:Luz
	remaining:Nut
	parsed:( success:Rest )
	module:( +:M2 -:M3 ) )
if:(
	h:Clause emnut:Rest hemnut:Result ).

:["TODO: Why do the remaining characters also get stripped here: ].

then:( parse:statement source:S remaining:R parsed:( success:empty )  module:( +:M -:M ) )
if:( stripWhitespace:S result:["] )
if:( stripWhitespace:R result:["] ).

then:(
	parse:clause
	source:Hemnut
	remaining:Luz
      parsed:S
      module:M )
if:(
	stripWhitespace:Hemnut result:Emnut )
if:( 
	canBeValue:V )
if:(
	parse:V
	source:Emnut
	remaining:Luz
	parsed:S
	module:M ).

then:( array:Source split:S hem:["] nut:Nut )
if:( h:S emnut:Nut array:Source ).

then:( array:Source split:S hem:Hem nut:Nut )
if:( h:B emnut:Okluz array:Source )
if:( notEqual:B with:S )
if:( array:Okluz split:S hem:Ok nut:Nut )
if:( h:B emnut:Ok array:Hem ).

then:( test:(clause:P) )
if:( 
	create:module result:Mb )
if:( 
	parse:clause
	source:["abc]
	remaining:["]
	parsed:P
	module:( +:Mb -:Ma )	
).

then:( test:(clause2:P) )
if:( 
	create:module result:Mb )
if:( 
	parse:clause
	source:["abc)]
	remaining:[")]
	parsed:P
	module:( +:Mb -:Ma )	
).

then:( test:( clause3:P) )
if:( 
	create:module result:Mb )
if:( 
	parse:clause
	source:["[+4]]
	remaining:["]
	parsed:P
	module:( +:Mb -:Ma )).

then:( test:( clause4:P) )
if:( 
	create:module result:Mb )
if:( 
	parse:statement
	source:["one two three ["hello]]
	remaining:["]
	parsed:P
	module:( +:Mb -:Ma )).

then:( test:( clause5:P) )
if:( 
	create:module result:Mb )
if:( 
	parse:clause
	source:["X]
	remaining:["]
	parsed:( success:P )
	module:( +:Mb -:Ma )).

:[" Remove parenthesis. ].

then:( 
	parse:parenthesizedStatement 
	source:Hemnut
	remaining:Nut
	parsed: (success:( Result ))
	module:( +:M1 -:M2 ) )
if:( h:['(] emnut:Emnut array:Hemnut )
if:( 
	parse:statement 
	source:Emnut 
	remaining:Mnut
	parsed:( success:Result ) 
	module:( +:M1 -:M2 ) )
if:( h:[')] emnut:Nut array:Mnut ).

canBeValue:variable.

canBeValue:literal.

canBeValue:parenthesizedStatement.

canBeValue:atom.

then:( test:(parseStatement:S))
if:(
	create:module result:M )
if:( 
	parse:statement
	source:["a a]
	remaining:["]
	parsed:(success:S)
	module:( +:M -:Ma ) ).

then:( test:(parseStatement2:S) )
if:(
	create:module result:M )
if:( 
	parse:statement
	source:["a b]
	remaining:["]
	parsed:(success:S)
	module:( +:M -:Ma ) ).

then:( test:(parseStatement3:S) )
if:(
	create:module result:M )
if:( 
	parse:statement
	source:["b ]
	remaining:Remaining
	parsed:(success:S)
	module:( +:M -:Ma ) )
if:( 
	stripWhitespace:Remaining result:["] ).

then:( test:(parseStatement4:S) )
if:(
	create:module result:M )
if:( 
	parse:statement
	source:["long atoms]
	remaining:Remaining
	parsed:(success:S)
	module:( +:M -:Ma ) )
if:( 
	stripWhitespace:Remaining result:["] ).

then:( test:(parseValueAtom:Value) )
if:(
	create:module result:M )
if:( 
	parse:clause
	source:["a]
	remaining:["]
	parsed:Value
	module:( +:M -:Ma ) ).

then:( test:(parseValueAtom2:Value) )
if:(
	create:module result:M )
if:( 
	parse:clause
	source:["a)]
	remaining:[")]
	parsed:Value
	module:( +:M -:Ma ) ).

then:( test:parseValueVariable )
if:(
	create:module result:M )
if:( 
	parse:clause
	source:["A]
	remaining:["]
	parsed:Value
	module:( +:M -:Ma ) ).

then:( test:parseValueInteger )
if:(
	create:module result:M )
if:( 
	parse:clause
	source:["[+1]]
	remaining:["]
	parsed:Value
	module:( +:M -:Ma )).

then:( test:( parseValueStatement:S ) )
if:(
	create:module result:M )
if:( 
	parse:clause
	source:["(a a)]
	remaining:["]
	parsed:S
	module:( +:M -:Ma ) ).

then:( test:( parseSubstatement:S ) )
if:(
	create:module result:M )
if:( 
	parse:statement
	source:["(b c) d]
	remaining:["]
	parsed:S
	module:( +:M -:Ma ) ).

then:( test:( parseSubstatement2:S ) )
if:(
	create:module result:M )
if:( 
	parse:statement
	source:["a (b c)]
	remaining:["]
	parsed:S
	module:( +:M -:Ma ) ).

:[" Atoms can contain any unicode codepoint that's not a separator ].

atomChars:["].

atomCharsRest:["].

then:( atomChars:Hemnut )
if:( h:H emnut:Emnut array:Hemnut )
if:( atomChar:H )
if:( noResults:( variableChar:H ) )
if:( atomCharsRest:Emnut ).

then:( atomChar:C )
if:( character:C )
if:( noResults:( separator:C ) ).

test:(  atomChar:['a] ).

then:( atomCharsRest:Hemnut )
if:( h:H emnut:Emnut array:Hemnut )
if:( atomChar:H )
if:( atomCharsRest:Emnut ).

test:( atomChars:["abcd] ).

test:( noResults:( atomChars:["XYZ] ) ).

test:( atomChars:["+aX12] ).

separator:['(].

separator:[')].

separator:['.].

separator:['?].

separator:['!].

separator:[' ].

then:( separator:X )
if:( openingSquareBracket:X ).

then:( separator:X )
if:( closingSquareBracket:X ).

then:( 
	parse:variable 
	source:Hemnut
	remaining:Nut
	parsed:(success:( variable:Hokluz ))
	module:( +:M1 -:M2 ) )
if:( h:H emnut:Emnut array:Hemnut )
if:( variableChar:H )
if:( 
	parse:atomChars
	source:Emnut
	remaining:Nut
	parsed:( success:( atomChars:Okluz ) )
	module:(+:M1 -:M2) )
if:( h:H emnut:Okluz array:Hokluz ).

then:( test:variable ) 
if:( 
	parse:variable 
	source:["Va]
	remaining:R
	parsed:(success:( variable:["Va]))
	module:(+:banana -:M) ).

then:( test:variable2 ) 
if:( 
	noResults: (
		parse:variable 
		source:["va]
		parsed:( success:(variable:X))
		module:(+:banana -:M)
	)
).

then:( variableChar:Sc )
if:( upperCase:Sc ).

test:( variableChar:['S] ).

test:( noResults:( variableChar:["s] ) ).

then:(
	parse:atom
	source:Hemnut
	remaining:Nut
	parsed:(success:( atom:Bokluz) )
	module:( +:M1 -:M2 ) )
if:( h:H emnut:Emnut array:Hemnut)
if:( atomChar:H )
if:( noResults: (variableChar:H) )
if:( 
	parse:atomChars
	source:Emnut
	remaining:Nut
	parsed:(success:( atomChars:Okluz) )
	module:( +:M1 -:M2 ) )
if:( h:H emnut:Okluz array:Bokluz ).

parse:atomChars
source:["]
remaining:["]
parsed:(success:( atomChars:["]) )
module:( +:M -:M ).

then:(
	parse:atomChars
	source:Hemnut
	remaining:Hemnut
	parsed:(success:( atomChars:["]) )
	module:( +:M -:M ) )
if:( h:H emnut:Emnut array:Hemnut)
if:( noResults:( atomChar:H ) ).

then:(
	parse:atomChars
	source:Hemnut
	remaining:Nut
	parsed:(success:( atomChars:Bokluz) )
	module:( +:M -:M ) )
if:( h:H emnut:Emnut array:Hemnut)
if:( atomChar:H )
if:( 
	parse:atomChars
	source:Emnut
	remaining:Nut
	parsed:(success:( atomChars:Okluz) )
	module:( +:M -:M ) )
if:( h:H emnut:Okluz array:Bokluz ).

then:( test:(atom:Atom) )
if:( create:module result:Ma )
if:( parse:atom
		source:["h]
		remaining:Extra
		parsed:(success:Atom)
		module:( +:Ma -:Mb ) ).

then:( test:(atom2:Atom) )
if:( create:module result:Ma )
if:( parse:atom
		source:["hello]
		remaining:Extra
		parsed:Atom
		module:( +:Ma -:Mb ) ).

then:( test:(atom3:Atom remaining:R) )
if:( create:module result:Ma )
if:( parse:atom
		source:["hello world]
		remaining:R
		parsed:(success:Atom)
		module:( +:Ma -:Mb ) ).

then:( test:atomChars )
if:( create:module result:M1 )
if:( parse:atomChars source:[" ] remaining:Nut parsed:( success:( atomChars:Okluz ) ) module:( +:M1 -:M2 ) ).

:[" Literals need to be parsed in two steps. First, make a statement skeleton. Second, populate the literals.].

:["TODO: I use ['[] below. This won't work.] ].

then:( 
	parse:literal
	source:Hemnut
	remaining:Nut
	parsed:( success:( literal:DecidingChar contents:LiteralS ))
	module:( +:M -:M2 ) )
if:( openingSquareBracket:Osb )
if:( h:Osb emnut:Emnut array:Hemnut )
if:( h:DecidingChar emnut:Mnut array:Emnut )
if:( 
	parse:literalContents
	source:Mnut
	remaining:Nut
	parsed:( success:( literalContents:LiteralS ))
	module:( +:M -:M2 ) ).

then:(
	parse:literalContents
	source:Hemnut
	remaining:Nut
	parsed:( success:( literalContents:["] ))
	module:( +:M -:M ) )
if:( closingSquareBracket:H )
if:( h:H emnut:Nut array:Hemnut ).

then:(
	parse:literalContents
	source:Hemnut
	remaining:Nut
	parsed:( success:( literalContents:Bokluz ))
	module:( +:M -:M2 ) )
if:( h:H emnut:Emnut array:Hemnut )
if:( openingSquareBracket:A )
if:( closingSquareBracket:B )
if:( notEqual:H with:B )
if:( notEqual:H with:A )
if:( 
	parse:literalContents
	source:Emnut
	remaining:Nut
	parsed:( success:( literalContents:Okluz ))
	module:( +:M -:M2 ) )
if:( h:H emnut:Okluz array:Bokluz).

then:( test:(parseLiteral1:Value) ) 
if:( create:module result:M )
if:( 
	parse:literal 
	source:["[ b ]]
	remaining:["]
	parsed:( success:Value ) 
	module:( +:M -:Mb ) ).

then:( test:(parseLiteral2:Value) ) 
if:( create:module result:M )
if:( 
	parse:literal 
	source:["["st]]
	remaining:["]
	parsed:( success:Value ) 
	module:( +:M -:Mb ) ).

then:( test:(parseLiteral3:Value) ) 
if:( create:module result:M )
if:( 
	parse:literal 
	source:["[+42]]
	remaining:["]
	parsed:( success:Value ) 
	module:( +:M -:Mb ) ).

then:( openingSquareBracket:SquareBracket )
if:( array:["[]] index:[+1] value:SquareBracket ).

test:(openingSquareBracket:B).

then:( closingSquareBracket:SquareBracket )
if:( array:["[]] index:[+2] value:SquareBracket ).

test:(closingSquareBracket:B).

:[" Is literalContents:~ used? It should succeed if a literal matches up it's square brackets correctly. Maybe it needs renaming. ].

literalContents:empty.

deleteme:[+8].

deleteme:[+9].

then:( test:( literalInteger:Int ) )
if:(
	create:module result:Mb )
if:( 
	parse:literal
	source:["[+1]]
	remaining:["]
	parsed:Int
	module:( +:Mb -:Ma ) ).

then:( test:( literalString:S ) )
if:(
	create:module result:M )
if:( 
	parse:literal
	source:["["hello world]]
	remaining:["]
	parsed:S
	module:( +:M -:_ ) ).

then:( test:( literalStatement:S ) )
if:(
	create:module result:M )
if:( 
	parse:literal
	source:["[\a]]
	remaining:["]
	parsed:S
	module:( +:M -:_ ) ).

then:( test:( literalArray:S ) )
if:(
	create:module result:M )
if:( 
	parse:literal
	source:["[ a]]
	remaining:["]
	parsed:S
	module:( +:M -:_ ) ).

:["TODO: a value can also be a naked number].

:[":-  ].

test:(atomChars:["foo]).

:["TODO: the terminator should be followed by whitespace. ].

terminator:['.].

terminator:['?].

terminator:['!].

whitespaceChar:[' ].

whitespaceChar:['
].

whitespaceChar:['	].

then:( whitespace:Hemnut ) if:( array:Hemnut size:S ) if:( whitespace:Hemnut atIndex:S ).

whitespace:Hemnut atIndex:[+0].

then:( whitespace:Hemnut atIndex:Idx )
if:( array:Hemnut index:Idx value:El )
if:( whitespaceChar:El )
if:( n:Idx plus:[-1] result:Idx2 )
if:( whitespace:Hemnut atIndex:Idx2 ).

test:( whitespace:[" 	    ] ).

test:( noResults:( whitespace:["a] ) ).

:[" Strip whitespace from the front of a string ].

then:( stripWhitespace:Hemnut result:Hemnut )
if:( cn:Hemnut size:[+0] ).

then:( stripWhitespace:Hemnut result:Hemnut )
if:( h:H emnut:Emnut array:Hemnut )
if:( noResults:( whitespaceChar:H ) ).

then:( stripWhitespace:Hemnut result:Bokluz )
if:( h:H emnut:Emnut array:Hemnut )
if:( whitespaceChar:H )
if:( stripWhitespace:Emnut result:Bokluz ).

test:( stripWhitespace:["  	abc] result:["abc] ).

:[" Handling new statements ].

test:( create:variableMapping result:V ).

then:( create:variableMapping result:V )
if:( create:dictionary result:V ).

then:( variableMapping:(+:(dictionary:V) -:(dictionary:V)) findOrAddMapping:(:A to:B) ) 
if:( module:V simpleQueryUnunified:( :A to:[\Something] ) iterator:It )
if:( iterator:It value:(:A to:B) next:_ ).

then:( variableMapping:(+:(dictionary:V) -:(dictionary:V2)) findOrAddMapping:(:A to:B) ) 
if:( module:V simpleQueryUnunified:( :A to:[\Something] ) iterator:It )
if:( iteratorIsExhausted:It )
if:( create:variable result:B )
if:( module:V add:( :A to:B ) result:V2 ).

then:( test:variableMapping1 )
if:( create:variableMapping result:V )
if:( variableMapping:( +:V -:_ ) findOrAddMapping:( :["X] to:[\X] ) ).

then:( test:variableMapping2 )
if:( create:variableMapping result:V1 )
if:( variableMapping:( +:V1 -:V2 ) findOrAddMapping:( :["X] to:X ) )
if:( variableMapping:( +:V2 -:_ ) findOrAddMapping:( :["X] to:X ) ).

:[" softStatement:module:variableMapping:hardened: - will convert, but not populate, a soft statement component to a hard statement component. ].

then:( softStatement:S module:( +:M1 -:M3 ) variableMapping:(+:V1 -:V2) hardened:H )
if:( equal:S with:( h:_ emnut:_ ) )
if:( module:(+:M1 -:M2) findOrCreateSignatureFrom:S  result:Signature )
if:( create:statement fromSignature:Signature module:M2 result:NewStatement )
if:( softStatement:S statement:NewStatement index:[+1] module:(+:M2 -:M3) variableMapping:(+:V1 -:V2) hardened:H ).

then:( softStatement:( variable:V ) module:( +:M -:M ) variableMapping:(+:V1 -:V2) hardened:Vm )
if:( variableMapping:(+:V1 -:V2) findOrAddMapping:( :V to:Vm ) ).

then:( softStatement:( atom:A ) module:( +:M1 -:M2 ) variableMapping:(+:V -:V) hardened:H )
if:( module:( +:M1 -:M2 ) findOrCreateAtom:A result:H ).

softStatement:( literal:A ) module:( +:M -:M ) variableMapping:(+:V -:V) hardened:A.

then:( test: (softStatementLeaf1:H ) )
if:( create:module result:M )
if:( create:variableMapping result:V )
if:( softStatement:( h:(atom:["b]) emnut:empty ) module:(+:M -:_) variableMapping:(+:M -:_ ) hardened:H ).

then:( test: (softStatementLeaf2:H ) )
if:( create:module result:M )
if:( create:variableMapping result:V )
if:( softStatement:( atom:["b] ) module:(+:M -:_) variableMapping:(+:M -:_ ) hardened:H ).

then:( test:( softStatementLeaf3:H ) )
if:( create:module result:M )
if:( create:variableMapping result:V )
if:( softStatement:( variable:["V] ) module:(+:M -:_) variableMapping:(+:V -:_ ) hardened:H ).

softStatement:empty statement:H index:_ module:(+:M -:M) variableMapping:(+:V -:V) hardened:H.

then:( softStatement:( h:V emnut:Emnut ) statement:NewStatement index:Idx module:( +:M1 -:M3 ) variableMapping:(+:V1 -:V3) hardened:Result )
if:( softStatement:V module:(+:M1 -:M2) variableMapping:(+:V1 -:V2) hardened:Vh )
if:( statement:NewStatement index:Idx value:Vh result:S2 )
if:( n:Idx plus:[+1] result:Idxn )
if:( softStatement:Emnut statement:S2 index:Idxn module:( +:M2 -:M3 ) variableMapping:(+:V2 -:V3) hardened:Result ).

then:( test:(softStatement1:H) )
if:( create:variableMapping result:V )
if:( create:module result:M1 )
if:( softStatement: (h:( atom:["a ]) emnut:(h:(atom:["b]) emnut:empty))
	module:( +:M1 -:M2 ) 
	variableMapping:(+:V -:V2)
	hardened:H ).

then:( test:( softStatement2:H) )
if:( create:variableMapping result:V )
if:( create:module result:M1 )
if:( softStatement: (h:( atom:["a ]) emnut:( h:(literal:[\a7600]) emnut:empty))
	module:( +:M1 -:M2 ) 
	variableMapping:(+:V -:_)
	hardened:H ).

then:( test:( softStatement3:H) )
if:( create:variableMapping result:V )
if:( create:module result:M1 )
if:( softStatement: ( h:(atom:["a]) emnut:( h:(variable:["X]) emnut:( h:(atom:["b]) emnut:( h:(variable:["X]) emnut:empty) ) ))
	module:( +:M1 -:M2 ) 
	variableMapping:(+:V -:_)
	hardened:H ).

then:( test:( softStatement4:H) )
if:( create:variableMapping result:V )
if:( create:module result:M1 )
if:( softStatement: ( h:(atom:["a]) emnut:(h:(literal:[+13]) emnut:empty ) )
	module:( +:M1 -:M2 ) 
	variableMapping:(+:V -:_)
	hardened:H ).

then:( test:( softStatement5:H) )
if:( create:variableMapping result:V )
if:( create:module result:M1 )
if:( softStatement: ( h:(atom:["a]) emnut:(h:(atom:["hello]) emnut:empty ) )
	module:( +:M1 -:M2 ) 
	variableMapping:(+:V -:_)
	hardened:H ).

then:( module:( +:M1 -:M2 ) findOrCreateAtom:A result:Atom )
if:( module:M1 simpleQuery:( metadata:( atom:[\Any] source:A ) ) numResults:[+0] )
if:( create:atom result:Atom )
if:( module:M1 add:( metadata:( atom:Atom source:A ) ) result:M2 ).

then:( module:( +:M1 -:M2 ) findOrCreateAtom:A result:Atom )
if:( module:M1 query:( metadata:( atom:[\Any] source:A ) ) iterator:It )
if:( iterator:It value:( metadata:( atom:Atom source:A ) ) next:_ ).

:["Soft signature handling ].

:["TODO: Search for declarations here instead and throw an error if not found. Currently I just add new signatures to the module willy nilly. ].

then:( module:(+:M1 -:M2) findOrCreateSignatureFrom:Soft  result:Signature )
if:( module:M1 simpleQuery:(metadata:( signature:[\X] softSignature:Soft ))  numResults:[+0] )
if:( cn:Soft size:Arity )
if:( create:statementSignature module:M1 arity:Arity result:Signature)
if:( module:M1 add:( metadata:( signature:Signature softSignature:Soft ) ) result:M2 ).

then:( module:(+:M1 -:M2) findOrCreateSignatureFrom:Soft  result:Signature )
if:( module:M1 simpleQueryUnified:(metadata:( signature:[\X] softSignature:Soft )) iterator:Itr )
if:( iterator:Itr value:( metadata:( signature:Signature softSignature:_ ) ) next:_).

clauses:empty toSoftSignature:empty.

then:( clauses:(h:H emnut:Emnut) toSoftSignature:(h:B emnut:Okluz) )
if:( :H asAtomOrType:B )
if:( clauses:Emnut toSoftSignature:Okluz ).

test:( 
	clauses:( h:(atom:["a]) emnut:( h:( h:(atom:["b]) emnut:empty) emnut:empty))
	toSoftSignature:( h:(atom:["a]) emnut:(h:_ emnut:empty) ) 
).

:(atom:A) asAtomOrType:(atom:A).

then:( :Z asAtomOrType:(type:todo) )
if:( notEqual:Z with:(atom:_) ).

test:(  
	clauses:( 
		h:(atom:["a])
		emnut:( 
			h:(atom:["b])
			emnut:empty
		) 
	)
	toSoftSignature:(
		h:( atom:["a] ) 
		emnut:( 
			h:( atom:["b] ) 
			emnut:empty ) )
).

test:(  
	clauses:( 
		h:(
			h:(atom:["a])
			emnut:empty )
		emnut:( 
			h:(atom:["b])
			emnut:empty
		) 
	)
	toSoftSignature:(
		h:( type:_ ) 
		emnut:( 
			h:( atom:["b] ) 
			emnut:empty ) )
).

then:( test:( findSignature2:S) )
if:( create:module result:M )
if:( module:M add:( metadata:( signature:a softSignature:(h:(atom:["a]) emnut:empty ) ) ) result:M2 ) 
if:( module:(+:M2 -:_) findOrCreateSignatureFrom:( h:( atom:["a] ) emnut:empty ) result:S ).

then:( test:( findSignature3:S ) )
if:( create:module result:M )
if:( module:(+:M -:M2) findOrCreateSignatureFrom:(h:(atom:["a]) emnut:(h:(atom:b) emnut:empty)) result:S ).

:["TODO clauses:C statement:S populatedStatement:Result 

Given the newly created, empty statement S and the clauses from which it was created, fill in the arguments of the statement with the contents of the clauses. ].

then:( clauses:C statement:S populatedStatement:Result )
if:( clauses:C clauseIndex:[+1] statement:S populatedStatement:Result ).

clauses:empty clauseIndex:_ statement:S populatedStatement:S.

:[" Cooking literals. After literals have been parsed, they also need to be cooked. "Cooked" means that all literals have been converted to statements (or other modifications to the module). UncookedLiterals is a soft statement. Result is a soft statement with all literals cooked.The user needs to provide the (cookLiteral:Literal statement:(+:S -Sr) module:(+:M -:Mr) )UncookedLiterals has not yet been added to the module. ].

cookLiterals:(+:empty -:empty) module:(+:M -:M).

then:( 
	cookLiterals:(
		+:(h:V1 emnut:Emnut )
		-:(h:V2 emnut:Okluz) )
	module: (
		+:M1
		-:Mr ) )
if:( cookLiteral:( +:V1 -:V2 ) module:( +:M1 -:M2 ))
if:( cookLiterals:( +:Emnut -:Okluz ) module:( +:M2 -:Mr ) ).

then:( cookLiteral:(+:Substatement -:Result) module:(+:M1 -:M2) )
if:(equal:Substatement with:(h:_ emnut:_))
if:(cookLiterals:(+:Substatement -:Result) module:(+:M1 -:M2)).

then:( cookLiteral:S module:(+:M -:M) )
if:( cookLiteral:S ).

then:( cookLiteral:( +:S -:S ) )
if:( notALiteral:S ).

notALiteral:(atom:_).

notALiteral:(variable:_).

then:( test:( cookLiterals1:Result ) )
if:( create:module result:M )
if:( 
    cookLiterals:( 
        +:( 
            h:( atom:["a] )
            emnut:( 
                h:(atom:["a] ) 
                emnut:( 
                    h:( literal:['+] contents:["12] ) 
                    emnut:empty 
                ) 
            )
        ) 
        -:Result 
    ) 
    module:( +:M -:_ ) 
).

then:( test:( cookLiterals2:Result ) )
if:( create:module result:M )
if:( 
    cookLiterals:( 
        +:( 
            h:( atom:["a] ) 
            emnut:( 
                h:( atom:["b] ) 
                emnut:( 
                    h:(literal:['"] contents:["hello] )
                    emnut:empty 
                ) 
            ) 
        ) 
        -:Result ) 
    module:( +:M -:_ ) 
).

then:( test:( cookLiterals3:Result ) )
if:( create:module result:M )
if:( cookLiterals:( +:( h:( literal:[' ] contents:["b ] ) emnut:empty ) -:Result ) module:( +:M -:M3 ) ).

then:( test:( cookLiterals4:Result ) )
if:( create:module result:M )
if:( cookLiterals:( +:( h:( atom:["a] ) emnut:( h:( h:( atom:["a] ) emnut:( h:( atom:["b] ) emnut:empty ) ) emnut:empty ) ) -:Result ) module:( +:M -:_ ) ).

then:( test:( cookLiterals5:Result ) )
if:( create:module result:M )
if:( cookLiterals:( +:(  h:( literal:[+92] contents:["a ] ) emnut:empty ) -:Result ) module:( +:M -:_ ) ).

test:( 
	statement:(
        +:(
            h:(atom:["foo]) 
            emnut:(
                h:( literal:['"] contents:["bar] )
                emnut:empty
            )
        )
        -:Sr
    )
	path:(h:[+1] emnut:empty) 
	replaceWith:["bar] ).

then:( statement:(	+:S1 -:S2 ) 
	path:( h:Idx emnut:empty ) 
	replaceWith:Bar )
if:( statement:(+:S1 -:S2) index:Idx replaceWith:Bar ).

then:( statement:(	+:S1 -:S3 ) 
	path:( h:Idx emnut:Emnut ) 
	replaceWith:Bar )
if:( statement:S1 index:Idx is:S2 )
if:( statement:( +:S2 -:S3 ) 
	path:Emnut
	replaceWith:Bar ).

statement:S index:[+1] is:S.

then:( statement:( h:_ emnut:Emnut ) index:Idx is:S )
if:( lesser:[+1] greater:Idx )
if:( n:Idx plus:[-1] result:Idx2 )
if:( statement:V index:Idx2 is:S ).

statement:(
	+:( h:_ emnut:Emnut )
	-:( h:ReplaceMe emnut:Emnut ) )
index:[+1] 
replaceWith:ReplaceMe.

then:( 
	statement:(
		+:( h:H emnut:Emnut )
		-:( h:H emnut:Okluz ) ) 
	index:Idx 
	replaceWith:Bar )
if:( n:Idx plus:[-1] result:Idx2 )
if:( lesser:[+1] greater:Idx2 )
if:( statement:( +:Emnut -:Okluz ) index:Idx2 replaceWith:Bar ).

:[" Strings ].

cookLiteral:( +:(literal:['"] contents:C) -:(literal:C) ).

test:( cookLiteral:( +:(literal:['"] contents:["Foo]) -:(literal:["Foo]) )).

:[" Integers ].

:[" TODO: allow whitespace ].

then:( cookLiteral:( +:(literal:['+] contents:C) -:(literal:R) ) ) 
if:( parse:C integer:R ).

then:( cookLiteral:( +:(literal:['-] contents:C) -:(literal:R) ) ) 
if:( parse:C integer:N )
if:( n:N multiply:[-1] result:R ).

test:( cookLiteral:( +:(literal:['+] contents:["13]) -:(literal:[+13] )) ).

test:( cookLiteral:( +:(literal:['-] contents:["13]) -:(literal:[-13]) ) ).

parseChar:['0] integer:[+0].

parseChar:['1] integer:[+1].

parseChar:['2] integer:[+2].

parseChar:['3] integer:[+3].

parseChar:['4] integer:[+4].

parseChar:['5] integer:[+5].

parseChar:['6] integer:[+6].

parseChar:['7] integer:[+7].

parseChar:['8] integer:[+8].

parseChar:['9] integer:[+9].

then:( parse:C integer:R )
if:( array:C size:[+1] )
if:( array:C index:[+1] value:Cv )
if:( parseChar:Cv integer:R ).

then:( parse:C integer:R ) 
if:( hemnu:Hemnu t:T array:C )
if:( parseChar:T integer:CN )
if:( parse:Hemnu integer:HemnuN )
if:( n:HemnuN multiply:[+10] result:HemnuN10 )
if:( n:HemnuN10 plus:CN result:R ).

test:( parse:["3] integer:[+3] ).

test:( parse:["13] integer:[+13] ).

:[" Floats ].

:["cookLiteral:(
 			+:(literal:['+] contents:[=He-|['.]|-Nut]			
			-:[=HeI+NutI/(10^(size(NutI)) ]) :-		
			parse:He integer:HeI,		
			parse:Nut integer:NutI.
].

:["Integer literals].

then:( cookLiteral:( +:(literal:['+] contents:C) -:(literal:R) )) 
if:( array:C split:[".] hem:Hem nut:Nut )
if:( parse:Hem integer:HemI )
if:( parse:Nut integer:NutI )
if:( cn:Nut size:DecimalPlaces ) 
if:( n:[+10] raisedTo:NutSize result:DR )
if:( n:NutI divide:DR result:AfterDecimal )
if:( n:HemI plus:AfterDecimal result:R ).

:["Array literals (TODO)].

then:( cookLiteral:( +:( literal:[+32] contents:ArraySource ) -:(literal:Literal ) ) module:( +:M1 -:M2 ))
if:(
	parse:statement
	source:ArraySource
	remaining:Remaining
	parsed:( success:Literal )
	module:( +:M1 -:M2 ) )
if:(
	stripWhitespace:Remaining result:["] ).

:["Statement literals. These make a soft statement.].

then:( test:(statementLiteral:X) ) 
if:( create:module result:M ) 
if:( cookLiterals:( +:( h:( literal:['\] contents:["a b] ) emnut:empty ) -:X )
	module:( +:M -:M3 ) ).

then:( test:(statementLiteral2:X) ) 
if:( create:module result:M ) 
if:( cookLiterals:( +:( h:( literal:['\] contents:["a (type int) b] ) emnut:empty ) -:X )
	module:( +:M -:M3 ) ).

then:( cookLiteral:( +:( literal:['\] contents:StatementSource ) -:SoftStatement ) module:(+:M1 -:M2) )
if:( 
	parse:statement 
	source:StatementSource 
	remaining:["]
	parsed:(success:SoftStatement)
	module:(+:M1 -:M2) ).

module:[	mParser159] metadata:( name:["Parser] ).

then:( test:addToVariableMapping )

if:( create:variableMapping result:V )

if:( variableMapping:( +:V -:V2 ) findOrAddMapping:( :["A] to: [\A] ))

if:( variableMapping:( +:V2 -:_) findOrAddMapping:( :["A] to: _ )).

:["Some more comprehensive tests. ].

then:( parseTest:ModuleSource result:R )
if:( create:module result:M1 )
if:( string:ModuleSource readSoftStatementsInto:(+:M1 -:R) ).

:[" TODO: tests for this code: ].

then:( hardenDeclarationsIn:( +:M3 -:M4 ) )
if:( module:M3 query:( softStatement:[\X] todo:todo ) iterator:It )
if:( module:( +:M3 -:M4 ) hardenDeclarationsIt:It ).

then:( module:( +:M1 -:M3 ) hardenDeclarationsIt:It ) 
if:( iterator:It value:SoftStatement nextIterator:It2 )
if:( module:(+:M1 -:M2) hardenStatement:SoftStatement )
if:( module:( +:M2 -:M3 ) hardenDeclarationsIt:It ).

then:( module:(+:M1 -:M3) hardenSignature:SoftSignature ) 
if:( softStatement:SoftSignature arity:A )
if:( create:statementSignature module:M1 arity:A result:Sig )
if:( module:M1 add:Sig result:M2 )
if:( module:M2 add:( signature:Sig source:SoftSignature ) result:M3 ).

test:( parseTest:["a.] result:_ ).

test:( parseTest:[" a b.] result:_ ).

test:( parseTest:["a b. ] result:_ ).

test:( parseTest:["a? b? ] result:_ ).

test:( parseTest:["a b. c d.] result:_ ).

test:( parseTest:["a (b c).] result:_ ).

test:( parseTest:["

:: [ a (type a_type) b (type b_type) ].
:: [ a ] (type a_type).
:: [ b ] (type b_type).
a a b b.

] result:_ ).

test:( parseTest:["

declare: [ a (type a_type) b (type b_type) ].
declare: [ a ] (type a_type).
declare: [ b ] (type b_type).
a a b b?

] result:_ ).

test:( parseTest:["

declare: [ a (type a_type) b (type u8array) ].
declare: [ a ] (type a_type).

a a b ["hello].

] result:_ ).

test:( parseTest:["

declare: [ a (type a_type) b (type integer) ].
declare: [ a ] (type a_type).
a:a b:[+41].

] result:_ ).

test:( parseTest:["

declare: [ a (type a_type) b (type integer) ].
declare: [ a ] (type a_type).
a:a b:[-41].

] result:_ ).

test:( parseTest:["

declare: [ a (type a_type) b (type c_type) ].
declare: [ a ] (type a_type).
declare: [ c (type c2_type) ].
declare: [ c ] (type c2_type).
a a b (c c).

] result:_ ).

test:( parseTest:["

declare: [ a (type a_type) b (type b_type) ].

a X b X.

] result:_ ).

test:( parseTest:["

declare: [ a (type a_type) b (type b_type) ].
declare: [ a (type a_type) ] (type b_type).
a X b (a X).

] result:_ ).

test:( parseTest:["thisIsALongLabel thisIsALongValue.] result:_ ).

test:( parseTest:["[ b ].] result:_ ).

test:( parseTest:["[\a].] result:_ ).

test:( parseTest:["[\ a (type int) b (type string) ].] result:_ ).

then:( test:( parseStatementLiteral:Result) ) 
if:( create:module result:M)
if:( parseStatement:["[\a].] module:(+:M -:_) result:Result ).

then:( test:Source query:Q result:R )
if:( parse:Source module:Mc )
if:( parse:Q inModule:Mc -:Qc)
if:( module:Mc query:Qc iterator:I)
if:( iterator:I value:R next:_).

test:( test:["
a b.
]
query:["a B?] result:R ).

test:( test:["
b a.
a X :- b X.
]
query:["a B?] result:R ).

then:( test:( parseQueryResult:R )) 
if:( create:module result:M )
if:( parse:["a B?] inModule:M -:R ).

module:[	mParser276] metadata:( importModule:[	mBase65] name:["Base] uri:unknown ).

